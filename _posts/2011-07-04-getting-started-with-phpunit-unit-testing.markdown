---
author: zcourts
comments: true
date: 2011-07-04 05:00:50+00:00
layout: post
slug: getting-started-with-phpunit-unit-testing
title: Getting started with PHPUnit unit testing
wordpress_id: 302
categories:
- General
- PHP
- Programming
- Tutorials
tags:
- class
- php
- phpunit
- test
- unit
- unit testing
---

The follow up to my[ previous post](http://crlog.info/2011/07/02/creating-a-string-class-to-represent-and-manipulate-strings-in-php/). The below is the php unit test class for the string class example I wrote.

<!-- more -->

[code lang="php"]
<!--?php require_once dirname(__FILE__) . '/../string.php'; /**  * Test class for String.  * Generated by PHPUnit on 2011-07-02 at 13:20:19.  */ class StringTest extends PHPUnit_Framework_TestCase {     /**      * @var String      */     protected $object;     /**      * Sets up the fixture, for example, opens a network connection.      * This method is called before a test is executed.      */     protected function setUp() {         $this--->object = new String("test");
    }

    /**
     * Must return null if the index is smaller than 0
     */
    public function testCharAtSmallIndex() {
        $this->assertNull($this->object->charAt(-1));
    }

    /**
     * Must return null if the index is bigger than the size of the string
     */
    public function testCharAtBigIndex() {
        $this->assertNull($this->object->charAt(5));
    }

    /**
     * Must return character at the said index
     */
    public function testCharAt() {
        $this->assertEquals('s', $this->object->charAt(2));
    }

    public function testToString() {
        $this->assertEquals('test', $this->object->toString());
    }

    public function testSize() {
        $this->assertEquals(4, $this->object->size());
    }

    /**
     * should return null if is an object and not an isnance of String
     */
    public function testCompareToIsObjectInstanceOf() {
        $this->assertNull($this->object->compareTo(new stdClass()));
    }

    /**
     * should return greater than 0 since "test" is greater than "me"
     */
    public function testCompareToIsObjectNOTInstanceOf() {
        $this->assertGreaterThan(0, $this->object->compareTo(new String("me")));
    }

//< 0 if str1 is less than str2; > 0 if str1 is greater than str2, and 0 if they are equal.
    public function testCompareToGreaterThan() {
        //if first assertion passes then compareto should return val >0
        $this->assertEquals(4, $this->object->size());
        $this->assertGreaterThan(0, $this->object->compareTo("was"));
    }

    public function testCompareToLessThan() {
        $this->assertLessThan(0, $this->object->compareTo("testing"));
    }

    public function testCompareToEquals() {
        $this->assertEquals(0, $this->object->compareTo("test"));
    }

    public function testCompareToEqualsBadChars() {
        $this->assertNotEquals(0, $this->object->compareTo("etst"));
    }

    //return -2 because of case mismatch
    public function testCompareToEqualsCaseSensitive() {
        $this->assertEquals(-2, $this->object->compareTo("Test"));
    }

    public function testCompareToEqualsCaseInSensitive() {

        $this->assertEquals(0, $this->object->compareTo("test"));
    }

    public function testCompareToGreaterThanCaseInSensitive() {
        $this->assertGreaterThan(0, $this->object->compareTo("was", false));
    }

    public function testCompareToLessThanCaseInSensitive() {
        $this->assertLessThan(0, $this->object->compareTo("testing", false));
    }

}
[/code]

I suppose the essence of this is to try to hammer out bugs as early as possible. PHPUnit, like JUnit and other unit testing frameworks provides the infrastructure you may need to create test cases quickly and easily.
By using assertions you tests for various possibilities and try to provide data that should break the code... I've read a few places where people suggest providing data that you expect a certain result for. Those sound like opposite things but they're in fact the same.
They're the same because if you provide data to break the program you then write assertions to check that the program responds with an error or something other than what should happen, an exception perhaps? If you then provide data that you know should get you the right result you go off to write assertions to check that the correct response is in fact returned... Either way what matters is the assertions you make.

Just my 2 cents but I think providing data to break everything will make for better results...or event better do it both ways.

The unit tests done on the compareTo method is fairly extensive and checks for every case i could think of at the time. For a set of available assertions in phpunit see [http://www.phpunit.de/manual/current/en/writing-tests-for-phpunit.html](http://www.phpunit.de/manual/current/en/writing-tests-for-phpunit.html)

all those tests should pass, if one fails check out the error and try to see why, play around with the expected values, i.e the first parameter in the assertion method calls.

Just found a very good quote:
<table cellpadding="0" width="100%" cellspacing="0" border="0" summary="Block quote" >
<tbody >
<tr >

<td width="10%" valign="top" >
</td>

<td width="80%" valign="top" >You can always write more tests. However, you will quickly find that only a fraction of the tests you can imagine are actually useful. What you want is to write tests that fail even though you think they should work, or tests that succeed even though you think they should fail. Another way to think of it is in cost/benefit terms. You want to write tests that will pay you back with information.
</td>

<td width="10%" valign="top" >
</td>
</tr>
<tr >

<td width="10%" valign="top" >
</td>

<td colspan="2" align="right" valign="top" >--Erich Gamma
</td>
</tr>
</tbody>
</table>

